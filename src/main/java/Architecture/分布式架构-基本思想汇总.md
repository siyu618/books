

# [分布式架构](https://blog.csdn.net/chunlongyu/article/details/52525604) 
       --- 基本思想汇总

### 分拆
* 系统分拆
   微信的架构师说过一句话：”大系统小做“。对于一个大的复杂系统，首先想到的就是对其进行分拆，才成多个子系统。每个子系统自己的存储/Service/接口层，各个子系统独立开发、测试、部署、运维。
* 子系统分拆
   拆成子系统之后，子系统内部又可以分层，分模块。当然这里”系统“、”子系统“、”层“、”模块“都只是一个相对的概念。在一个系统里面，某个模块复杂到一定程度，就会把它抽象出来，单独做成一个系统；而在初期，很大的简单模块，可能不会拆分，集中在一个系统里面。
   这就像一个生物组织，自身在不断成长、演化、有分有合，不断变化发展的。
* 存储分拆
   NoSQL：对于 NoSQL 数据库，比如 MongoDB，其天生就是分布式的，很容易实现数据的分片。
   MySQL：对于 MySQL 或者其他的关系型数据库，就会涉及到分库分表，就会涉及到几个关键性的问题：切分维度、join 的处理、分布式事务。
* 计算分拆
   计算的分拆有两种思路：
   1. 数据拆分：一个大的数据集，拆分成多个小的数据集，并行计算。
      * 比如大规模数据的归并。
   2. 任务拆分：把一个长的任务，拆分成几个环节，各个环节并行计算。
      * Java 中多线程的 Fork/Join 框架，Hadoop 中的 Map/Reduce，都是计算分拆的经典框架。其思路是相似的，先分拆计算，再合并结果。 
      * 再比如分布式的搜索引擎中，数据分拆、分别建索引，查询结果再合并。

### 并发
* 最常见的就是多线程，尽可能提高程序的并发度。
   * 比如多次 RPC 顺序调用，通过异步 RPC 转化为并发调用。
   * 比如数据分片，你的一个 Job 要扫描全表，跑几个小时，数据分片，用多线程，性能会加快好几倍。
### 缓存
* 缓存一般不陌生，遇到性能问题，大家首先想到的就是缓存。关于缓存，一个关键点就是：缓存的粒度问题。
   * 比如 Tweet 的架构中，缓存粒度从小到大，有 Row Cache、Vector Cache、Fragment Cache、Page Cache。
* 粒度越小，重用性越好，查询需要多次，需要数据拼装。
* 粒度越大，越容易失效，任何一个小的地方改动，都可能造成缓存的失效。   
### 在线计算 VS. 离线计算 / 同步 VS. 异步
* 在实际的也无需求中，并不是所有需要都需要完全实时的：
   * 比如内部战队产品、运营开发的各种报表查询、分析系统。
   * 比如微博的传播，我发了一个微博，我的粉丝延迟几秒钟才看到，这是可以接受的，因为他并不会注意到晚了几秒。
   * 比如搜索引擎的索引，我发了一篇博客，可能几分钟之后，才会被搜索引擎索引到。
   * 比如支付宝转账、提现，也并非这边转出之后，对方立即收到。
* 这类例子非常多。这种”非实时也可以接受“的场景，就为架构的设计赢得了充分的回旋余地。
* 因为非实时，我们就可以做异步，比如使用消息队列，比如使用后台的 Job，周期性处理某类任务。
* 也因为非实时，我们可以做读写分离，读和写不完全是同步的，比如 MySQL 的 Master-Slave。      
### 全量 + 增量
* 全量/增量 其实也是 在线/离线 的思路。
   * 比如搜索引擎的全量索引 + 增量索引，前者是为了吞吐，后者是为了实时。
   * 比如 OceanBase 数据库，每次更新存在一个小表里面，定期 merge。 

### Push VS. Pull
* 在所有的分布式系统中，都涉及到一个基本问题：节点之间（或者两个子系统之间）的状态通知。比如一个节点状态变更了，要通知另外一个及诶按，都有两种策略。
   1. Push：节点 A 状态变了，push 给节点 B
   2. Pull：也就是轮询。节点 B 周期性的去询问节点 A 的状态。
* 这个问题不光出现在分布式系统中，可以说是编写代码的一个基本问题。对应到面向对象的编程中，也就是常说的“双向关联”这种耦合问题。
* A 调用 B，B 再回调 A，这种情形，在系统开发中经常出现。再复杂一点，多个模块之间，彼此调用，调用关系跟蜘蛛网一样。
   * 这个问题的出现，就和 Push/Pull 的策略密切相关：
      * A 调用 B 那逻辑就会写在 B 这边。
      * B 调用 A 那逻辑就会写在 A 这边。
    * 所以是采用主动调用的 Pull 方式，还是回调的 Push 方式，会严重硬性智者在各个模块或子系统里面的分配。    

### 批量
* 批量其实也是在线/离线的一种思想，把实时问题，转化为一个批量处理的问题，从而降低对系统吞吐量的压力。
   * 比如 Kafka 中的批量发消息
   * 比如广告扣费系统中，吧多次点击累计在一起扣费。

### 重写轻读 VS. 重读轻写
* 重写轻度，本质上就是“空间换时间”。你不是计算起来耗时，延时高吗，那我可以提前计算，然后存储起来。取的时候，直接去取。
* 我们通常对 MySQL 的用法都是重读轻写，写的时候，简单；查的时候，做复杂的 join 计算，返回结果。这样做的好处是容易做到数据的强一致性，不会因为字段冗余，造成数据的不一致。但是性能可能就是问题。
* 而微博的 feeds 架构，就是典型的重写轻度，我要去看 feeds，按照通常的 MySQL 的做法，我要先去查我关注的所有的人，然后把所有人的消息排序，分页返回。很显然，在大数据量下，这个会很耗时。
* 而如果采用重写轻读呢，怎么做呢？你不是要看 feeds 嘛，那我就为每个人准备一个 feeds，或者说收件箱。某个人发了微博之后，把他的微博扩散到所有的收件箱箱，这个扩散是异步的，在后台扩散。这样每个人看自己的 feeds 的时候，直接去自己的邮箱取就可以了。

### 读写分离
* 同样，对传统的单机 MySQL 数据库，读和写是完全同步的。写进去的内容，立马就可以读到。
* 但在很多场景下，读和写并不需要完全同步。这个时候，就可以分开存储，写到一个地方，在异步同步到另一个地方。这样就可以实现读写分离。
   * 比如 MySQL 的 Master/Slave 就是个典型，Slave 上面的数据并不是和 Master 实时同步的。
   * 再比如各种报表分析，OLTP/OLAP，线上/线下数据Fenix，线上数据定期同步到 Hive 集群，再做分析。

### 动静分离
* 动静分离的典型例子就是网站的前端，动态的页面，放在 web 服务器上；静态的 CSS/JS/IMG，直接放到 CDN 上，这样既提高了性能，也极大降低了服务器的压力。
* 按照这个思路，很多大型网站都致力于动态内容的静态化，静态化之后可以很容易做到缓存。

### 冷热分离
* 比如定期把 MySQL 中的历史数据，同步到 Hive。

### 限流
* 现在很多电商都会有秒杀活动，秒杀的一个特点就是商品很少，单短时间内的流量暴增，服务器完全处理不了这么多的请求。
* 应对这类问题的一个基本思路就是限流，既然处理不了那么多请求，既然很大部分人进去也是抢不到的，那么索性就不要放那么多人进去。
* 这个和我们日常生活中，节假日，某个景点人数过多，限制人流量是同样的道理。

### 服务熔断与降级
* 服务器降级是系统的最后一道保险。在一个复杂系统的内部，一个系统往往会调用其他的很多系统。在大流量的情况下，我们可能会保证主流程能够正常工作的情况下，对其他服务做降级处理。
* 所谓降级，也就是当某个服务不可用时，干脆就别让其提供服务了，直接返回一个缺省的结果。虽然这个服务不可用，但它不至于让整个主流程瘫痪，这就可以最大限度的保证核心系统的可用了。

### CAP 理论
* 上面讲的各种思想，用一个更大的思想来概括就是 CAP。
   * Consistency：数据一致性，没有脏数据。我们知道 MySQL 中有一致性的概念，比如参照完整性约束、事务等。但这里的 C 主要特指同一份数据的多个备份之间的一致性。
   * Availability：可用性。这包含两个方面：一是稳定性，服务可用，不会挂；另外一个是性能，也就是要快，如果延迟很高，经常超时，那么就和挂了也就区别不大了。
   * Partition tolerance：分区容错性，分区是指网络分区。当吧数据从一个物理设备，分到多个物理设备之后，设备之间必然是通过网络进行通信。这就会遇到网络分区，也就是典型的“2 将军问题”，网络超时不定。学术上有个词，叫做“异步通信环境”。
* 以前说 CAP 理论，就说对于一个分布式系统，上面 3 ，只能同时满足两个。但是这个其实不准确，P 是一定存在的，其实主 ，要是在 C 和 A 之间权衡。
   * 比如拿 MySQL 来说，他的 C 最强， A 次之，P 最弱。如果为了 A，给数据做冗余，比如重写轻度，那么 C 上面就很难保证；为了 P，给数据做分区分表，那么事务就会复杂。
   * 比如 NoSQL，P 最强，可以很好的做数据拆分，但 C 就不够，做不了事务。
   * 比如微博系统，对 C 的要求降低，就可以加很多缓存，提高 A；数据分片，提高 P；
   * 而支付，交易转账，对 C 的要求就很高，就不能简单的用 Cache 来提高性能。

### 最终一致性
* 前面提到，在分布式系统中，因为数据的分拆、服务的分拆，强一致性就很难保证。这个时候，用的最多的就是最终一致性。
* 强一致性、弱一致性、最终一致性，是一致性的几个不同等级。在传统的关系型数据库中，通过事务来保证强一致性。
* 但是在分布式系统中，通常都会把强一致性折中成最终一致性，从而变相解决分布式事务的问题。
* 典型的转账例子，A 给 B 转账 1w，A 的账号扣除 1w，B 的账号增加 1w。这两步未必需要同时发生，A 的扣完之后，B 的账号未必马上就有，但只要保证 B 最终可以收到就可以了。
* 最终一致性的实现，通常就需要一个高可靠的消息队列。
      
      
      
      
      
      
      
      
      
      
      
      