**Chapter 1:分布式架构 **

1.1 从集中式到分布式
   * 集中式
       * 部署简单
   * 分布式
       * 分布性，对等性，并发性，缺乏全局时钟，故障总是会发生
   * 分布式的各种问题
       * 通信异常
       * 网络分区
       * 三态：成功、失败、超时
      
1.2 从ACID到CAP/BASE
   * ACID
      * Atomicity：全部执行或者全部为执行
      * Consistency：一致性
      * Isolation：隔离性，事务之间是相互隔离的
         * 未授权读取
         * 授权读取
         * 可重复读取
         * 串行化
      * Durability：一旦提交，即是永久
   * CAP
      * 分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）和分区容错（Partion tolerance），最多只能同时满足两个
      * C：多个副本之间保持一致性
      * A：请求在有限时间内返回结果
      * P：遇到网络分区故障时，仍然你需要对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了变化
      * 放弃CAP
         * 放弃P：为了避免系统出现分区容错性问题，简单做法是将所有的数据都放在一个分布式节点上。放弃P的同时，也就放弃了系统的可扩展性
         * 放弃A：放弃可用性是一旦系统遇到网络分区或者其他故障时，那么受到影响的服务需要等待一定的时间，因此在等待恢复的时间里，服务不可用。
         * 放弃C：是指放弃强一致性，从而保留系统的最终一致性
      * 结论
         * 分区容错是一个基本需求
         * 系统架构师需要经历花在如何根据业务特点在C和A之间寻求平衡。
   * BASE
      * 无法做到强一致性，单每个应用都可以根据自身的业务特点，采取适当的方式来时系统达到最终一致性
      * 基本可用（Basically Available）
         * 系统仍然可用
            * 响应时间上的损失
            * 功能上的损失
      * 弱状态/软状态（Soft state）
         * 允许系统当中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性
      * 最终一致性（Eventually consistent）
         * 强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态
         * 五种主要变种
            * 因果一致性
            * 读己之所写
            * 会话一致性
            * 单调读一致性
            * 单调写一致性
      * 面向大型高可用可扩展的分布式系统 
      


**Chapter 2:一致性协议**

经典的一致性

2.1 2PC & 3PC

为了保证事务处理的ACID特性，就需要引入一个称谓协调者（Coordinator）的组件来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称谓参与者（Participant）。
   * 2PC ： Two-Phase Commit
      * 目前绝大部分数据库采用两阶段提交来完成分布式事务处理，利用该协议能方便完成所有分布式事务的协调，统一决定事务的提交或回滚，从而能够有效地保证分布式数据库一致性。
      * 将事务分解为两个阶段来处理
      * 阶段1：提交事务请求 （投票阶段）
         1. 事务查询：协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待参与者的相应。
         1. 执行事务：各参与节点执行事务操作，并将Undo和Redo信息记入事务的日志中。
         1. 各参与者向协调者反馈事务询问的响应
            * 如果可以成功执行返回YES，否吃返回NO
      * 阶段2：执行事务提交 （Commit）
         1. 执行事务提交：如果所有参与者返回的是都是YES，则会执行事务
            * 发送提交请求：协调者向所有参与者节点发出Commit请求
            * 事务提交：参与者受到commit请求，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源
            * 反馈事务提交结果：向协调者反馈ACK消息
            * 完成事务：done
         1. 中断事务：任一参与者想协调者反馈了NO
            * 发送回滚请求：协调者发送Rollback请求
            * 事务回滚：参与者利用Undo信息来执行事务的回滚操作
            * 返回事务回滚的结果：向协调者发送ACK
            * 中断事务：协调者接收到所有参与者反馈的ACK消息后，完成事务中断
       * 优缺点
          * 优点：原理简单，实现方便
          * 缺点：同步阻塞、单点问题（协调者）、脑裂、太过保守（没有容错机制）
   * 3PC：Three-Phase Commit
      * canCommit，preCommit，do Commit
      * canCommit
         * 事务询问：协调者向参与者发送包含事务内容的canCommit请求
         * 各参与者向协调者反馈事务询问的相应，YES or NO
      * PreCommit
         * 执行事务的预提交：协调者获得了所有的YES
            1. 发送预提交请求：协调者向参与者发送preCommit请求，并进入prepared状态
            1. 事务预提交：参与者接收preCommit请求，会执行事务操作，并将Undo和Redo信息记录到事务日志中
            1. 各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，则会返回ACK，同时等待最终的指令：提交（commit）或终止（abort）
         * 中断事务：协调者或者至少一个NO
            1. 发送中断请求：发送abort请求
            1. 中断事务：收到abort请求，或者等待协调者超时，参与者都会中断事务
      * doCommit
         * 执行提交
            1. 发送提交请求
            1. 事务提交
            1. 反馈事务提交结果
            1. 完成事务
         * 中断事务
            1. 发送中断请求
            1. 事务回滚
            1. 反馈事务回滚结果
            1. 中断事务
      * 优缺点
         * 相对于2PC，降低了参与者的阻塞范围，并能再出现单点故障后继续达成一致
         * 缺点：出现网络分区后，出现数据不一致的情况 

2.2 Paxos算法
   * 理论上讲：分布式计算机领域，试图在异步系统和不可靠的通道上来达到一致性状态是不可能的。（拜占庭将军问题）
   * 问题描述
      假设有一组可以提出提案的进程集合，都那么对于一个一致性算法来说需要保证一下几点
         1. 在这些被提出的提案中，只有一个会被选定
         1. 如果没有提案被提出，也就不会有被选定的提案
         1. 当一个提案被选定后，进程应该可以获取被选定的提案的信息
      对于一致来说，安全性需求如下
         1. 只有被提出的提案才能被选定
         1. 只有一个值被选定
         1. 如果某个进程认为提案被选定了，那么这个必须是真的被选定的那个
   * 三种参与者：Proposer， Acceptor和Learner
   * 提案的选定
      * 单一Acceptor，存在单点问题
      * 多个Acceptor，Proposer向一个Acceptor集合发送提案，同样集合中的每个Acceptor都可能会批准（Accept）该提案的时候，则认为该提案被选定了。
         * Acceptor集合为超过一半
   * 推导过程
      * P1: 一个Acceptor必须批准他接收到的第一个提案
      * P2: 如果编号为M0，Value值为V0的提案(M0,V0)被选定了，那么所有比编号M0更高且被选定的提案，其Value值也为VO
      * P2a: 如果编号为M0，Value值为V0的提案(M,V0)被选定了，那么所有比编号M0更高且被Acceptor批准的提案，其Value值必须是V0
      * P2b: 如果一个提案(M0,V0)被选定后，那么任何Proposer产生的编号更高的提案，其Value值都是V0
      * P2c: 对于任意的Mn和Vn，如果提案(Mn, Vn)被提出，那么肯定存在一个由半数以上的Acceptor组成的集合S，满足一下两个条件中的任意一个
         * S中不存在任何批准过编号小于Mn提案的Acceptor
         * 选取S中所有Acceptor批准过的编号小于Mn的提案，其中编号最大的那个其Value值是Vn
   * Proposer生成提案
      1. Proposer选择一个新的提案编号Mn，然后向某个Acceptor集合的成员发送请求，要求该集合中的Acceptor做出如下的响应
         * 向Proposer承诺，保证不再批准任何标号小于Mn的提案
         * 如果Acceptor已经批准过任何天，那么其就想Proposer反馈当前该Acceptor已经批准的编号小于Mn但为最大编号的那个提案的值
      1. 如果Poposer收到来自半数以上的Acceptor的响应结果，那么他就可以产生编号为Mn，值为Vn的提案，这里的Vn是所有响应中编号最大的提案的Value值。当然还存在另一中情况，就是半数以上的Acceptor都没有批准过任何提案，那么此时Vn值就可以有Proposer任意选择
   * Acceptor批准提案
      * Acceptor响应Proposer的请求
         * Prepare请求：Acceptor可以再任何时候响应一个Prepare请求
         * Acceptor请求：在不违背Acceptor现有承诺的前提下，可以响应Acceptor请求
         * 算法优化：如果一个Acceptor收到一个编号Mn的Prepare请求，但此时已经对编号大于Mn的Prepare请求做出了响应，则可以丢弃该请求
      * 算法陈述
         * 阶段一
            1. Proposer选择一个提案编号Mn，然后向Acceptor的某个超过半数的自己成员发送编号为Mn的Prepare请求
            1. 如果一个Acceptor受到一个编号为Mn的Prepare请求，且编号Mn大于把你Acceptor已经相应的所所有Prepare请求的编号，那么它就会将已经批准过的最大编号的提案作为相应反馈给Proposer，同时该Acceptor会承诺不会再批准任何编号小于Mn的提案
         * 阶段二
            1. 如果Proposer收到来自半数以上的Acceptor对于其发出的编号为Mn的Prepare请求的相应，那么它就会发送一个针对(Mn,Vn)提案的Accept请求给Acceptor。注意Vn的值就是接收到相应编号最大的天的值，如果响应中不好好任何提案，那么它就是任意值
            1. 如果Acceptor收到这个针对(Mn,Vn)提案的Acceptor请求，只要改Acceptor尚未对编号大于Mn的Prepare请求做出响应，它就可以通过这个提案
   * 提案的获取（Learner）
      * 方案1：Acceptor发送所有批准的提案给所有的Learner
      * 方案2：Acceptor发送所有批准的提案给主Learner
      * 方案3：Acceptor发送所有批准的提案给主Learner集合
   * 选取主Porposer保证算法的活性 
      * 防止死循环
      
      