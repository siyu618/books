# 领域驱动设计：软件核心复杂性应对之道
* 不是“先建模，再实现”的固定思维模式
   * 强大的领域模型是随着时间演进出来的，即使是最有经验的建模人员也往往发现他们是在系统的最初版本完成之后才有了最好的想法。

### 前言
* 复杂性的挑战
   * 很多因素可能会导致项目偏离轨道，如官僚主义、目标不清、资源缺乏等。
   * **真正决定软件复杂性的是设计方法**。
* 本书的两个前提
   * 1. 在大多数软件项目中，主要的交点应该是领域和领域逻辑。
   * 2. 复杂的领域涉及应该基于模型。
* 项目必须遵循的两个开发实践
   * 1. 迭代开发
   * 2. 开发人员与领域专家具有密切的关系  

   
## 第一部分：运用领域模型
* 模型是一种抽象，一种简化
   * 用来描绘人们所关注的现实或想法的某个方面。
   * 对现实的解释 —— 把与解决问题密切相关的方面抽象出来，而忽略无关的细节。
   * **领域模型不是某种特殊的图，而是这类图所要传达的思想。**
      * 领域模型是对只是严格的值且有选择的抽象
* 模型在领域驱动设计中的作用   
   * 1. 模型和设计的核心互相影响
   * 2. 模型是团队所有成员使用的通用语言的中枢
   * 3. 模型是浓缩的知识
* 软件（是一个系统）的核心
   * 软件的核心是其为用户解决领域的相关的问题的能力。

### Chapter 1：消化知识
* 有效建模的要素：
   * 1. 模型和实现的绑定
   * 2. 建立了一种基于模型的语言
   * 3. 开发一个蕴含丰富知识的模型
   * 4. 提炼模型
   * 5. 头脑风暴和实验
* 知识消化
   * 高效的领域建模人员是知识的消化者
   * 知识消化并对非一项鼓励的活动，它一般是在开发人员的领导下，由开发人员与领域专家组成的团队来共同协作。
   * 与传统的瀑布模型相比，这里存在的反馈回路。
* 持续学习
   * 当开始编写软件时，其实我们所知甚少。
   * 积累知识，持续学习。
* 知识丰富的设计
   * 发现名词，创造概念
* 深层模型
   * 模型很少会停留在表面。
   * 模型本身也是迭代进化的。
   * 精通领域知识 + 精通建模技术。        

### Chapter 2：交流与语言的使用
* 模式：Ubiquitous Language
   * 语言
      * 如果语言是支离破碎，项目必将遭遇严重问题。领域专家使用的是自己的术语，而技术团队使用的语言则经过了调整，以便从设计角度讨论领域。
      * 日常讨论所使用的的术语和代码（软件项目的最重要产品）中使用的术语不一致。甚至同一个人在讲话和写东西时使用的语言也不一致，这导致的后果是，对领域的深刻表述常常稍纵即逝，根本无法记录到代码或文档中。
      * 翻译使得沟通不畅，并削弱了知识消化。
      * 然而任何一方的语言都不能成为公共语言，因为它们无法满足所有的需求。
   * 模型
      * 将模型作为语言的支柱。确保团队在内部的所有交流中以及代码中坚持使用这种语言。在画图、写东西，特别是讲话时也要使用这种语言。
      * 通过尝试不同的表示方法（他们反映了备选模型）来小锤难点。然后重构代码，重新命名类、方法和模块，以便与新模型保持一致。解决交谈中的术语混淆问题，就像我们队普通词汇形成一指的理解一样。
      * 要认识到，Ubiquitous Language 的更改就是对模型的更改。
      * 领域专家应该抵制不合适或无法充分表达领域理解的术语或结构，开发人员应该密切关注那些将会妨碍设计的有歧义的和不一致的地方。
* 大声的建模
   * 讨论系统时要结合模型。使用模型元素机器交互来大声描述场景，并且按照模型允许的方式将各种概念结合到一起。找到更简单的表达方式来讲出你要讲的话，然后将这些新的想法应用到图和代码中。      
* 一个团队，一种语言
   * 开发语言 VS. 业务语言
   * 领域模型术语
* 文档和图
   * 设计的重要细节应该在代码中体现出来。
   * 书面设计文档
      * 文档应作为代码和口头交流的补充
         * 温昂不应在重复表示代码已经明确表达出的内容。
      * 文档应该现货并保持最新
         * 文档必须深入到各种项目活动中去
   * 完全依赖可执行代码的情况
      * XP
* 解释性模型
   * 不必是对象模型，而且最好不是。 

### Chapter 3：绑定模型和实现
* 模式：Model-DrivenDesign
   * 如果整个程序设计或者其核心部分没有与领域模型相对应，那么这个模型就是没有价值的，软件的正确性也值得怀疑。同时，模型和设计功能之间过于复杂的对应关系也是难于理解的，在实际项目中，当设计改变时也无法维护这种关系。若分析与和设计之间产生严重分歧，那么在分析和设计活动中所获得的知识就无法彼此共享。
   * 软件系统各个部分的设计应该是忠实地反应领域模型。一遍体现出这两者之间的明确对应关系。我们应该反复检查并修改模型，一遍软件可以更加自然地实现模型，及时想让模型反映出更深层次的领域概念时也应如此。我们需要的模型不但应该满足这两种需求，还应该能够支持健壮的 Ubiquitous Language。
   * 从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达，代码的改变可能回事模型的改变。而其影响势必要波及接下来的相应的项目活动。
   * 完全依赖模型的实现通常需要支持建模范式的软件开发工具和语言，比如面向对象的编程。
* 建模范式和工具支持
   * 呆板的设计 VS. Model-Driven Design
* 揭示主旨：为什么模型对用户至关重要
   * 模型关联
* 模式：Hands-On Modeler
   * 如果编写代码的人员认为自己没必要对模型负责，或者不知道如何让模型Wie应用程序服务，那么这个模型就和程序没有任何关联。如果开发人员没有意识到改编代码就意味着改变模型，，那么他们对程序的重构不但不会增强模型的作用，反而还会削弱它的效果。同样，如果建模人员不参与到程序实现的过程中，那么程序实现的约束就没有切身的感受，及时有，也会很快忘记。Model-Driven Design 的两个基本要素（及模型要支持有效的实现并抽象出关键的领域知识）已经失去了一个，最终模型将别按的不再实用。最后一点，如果分工阻断了设计人员与开发人员之间的协作，是他们无法转达实现 Model-Driven Design 的种种细节，那么经验丰富的设计人员则不能将自己的知识和技术传递给开发人员。
   * 任何参与建模的技术人员，不管在项目中的主要智者是什么，都必须花时间了解代码，任何负责修改代码的人员都必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型讨论并且与领域专家保持联系。参与不同工作的人都必须有意识地通过 Ubiquitous Language 与接触代码的人及时交换关于模型的想法。


## 第二部分：模型驱动设计的构造
### Chapter 4：分离领域
* 模式：Layered Architecture
   * 在面向对象的程序中，常常会在业务对象中直接写入用户界面、数据库访问等支持代码。而一些业务逻辑则会被嵌入到用户界面组件和数据库脚本中。这么做是为了以最简单的方式在短期内开发完成。
   * 如果与领域有关的代码分散在大量的其他代码之中，那么查看分分析领域代码就会变得异常困难。对用户界面的简单修改实际上很可能会改变业务逻辑，而要想调整业务规则也很可能需要面对用户界面代码、数据库操作代码或者其他的程序元素进行仔细的筛查。这样就不太可能实现一致的、模型驱动的对象了，同时也会给自动化测试带来困难。考虑到程序中各个活动所涉及的大量逻辑和技术，程序本身必须简单明了，否则就会让人无法理解。
   * 分层的价值在于每一层都只代表程序中的摸一个方面。内聚

|层|功能|    
|---|---|
|用户界面层（或表示层）|负责向用户现实信息和解释用户指令。这里指的用户可以是另一个计算机系统，不一定是使用用户界面的人。|
|应用层|定义软件要完成的任务，并且指挥表达领域概念的对象来解决问题。这一层所负责的工作对业务来说意义重大，也是与其他系统的应用层进行角度的必要渠道。<br/> 应用层要尽量简单，不高喊业务规则或者知识，而只为下一层中的领域对象协调任务，分配工作，使它们互相协作。它没有反应业务情况的状态，但是却可以具有另外一种状态，为用户或程序显示某个任务的进度。|
|领域层（或模型层）|负责表达业务概念，业务状态信息以及业务规则。尽管保存业务状态的技术细节是有基础设施层实现的，但是反应业务情况的状态是由本层控制并且使用的。**领域层是业务软件的核心**|
|基础设施层|为上面各层提供通用的技术能力：为应用层传递小气，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持四个层次之间的交互模式。|

   * 给复杂的应用程序划分层次。在每一层内分别进行设计，使其具有内聚性并且只依赖与他的下层。采用标准的架构模式，只与上层进行松散的耦合。将所有与领域模型相关的代码放在一个层中，并把它与用户界面层、应用层以及基础设施层的代码分开。领域对象应该讲重点放在如何表达领域模型上，而不需要考虑自己的现实和存出问题，也无需管理应用任务等内容。这使得模型的含义足够而丰富，结构足够清晰，可以捕捉到基本的业务知识，并有效地使用这些知识。
   * 各层之间关联
      * 层之间是松散连接的，曾与层的依赖关系只能是单向上的。
         * 上层调可以直接使用或操作下层元素的公共接口，保持对下层元素的引用，以及采用常规交互手段。
         * 下层使用架构模式来连接上层，如回调模式或 Observer 模式。
      * 架构框架
         * 可以提高开发效率和程序质量。
         * 精细的框架也可能会束缚住程序开发人员。
* 领域层是模型的精髓
   * Model-Driven Design
* 模式：The Smart UI 反模式
   * 如果一个经验并附丰富的项目团队要完成一个简单的项目，却决定使用Model-Driven Design 以及 Layered Architecture，那么这个项目组将会经历一个艰难的学习过程。团队成员不得不去掌握复杂的新技术，艰难地学习对象建模。对基础设施和各层的管理工作使得原本简单的任务却要花费很长的时间来完成。简单项目的开发周期较短，期望值也不是很高。所以，早在项目团队完成任务之前，该项目就会被取消，更谈不上去论证有关这种方法的许多中令人激动的可行性了。
   * 即使项目有更充裕的时间，如果没有专家的帮助，团队成员也不太可能掌握这些技术。最后，加入他们确实能够克服这些困难，恐怕也只会开发出一套简单的系统。因为这个项目本来就不需要丰富的功能。
   * 在用户界面中实现所有的业务逻辑。将应用程序分成小的功能模块，分别将它们实现成用户界面，并在其中嵌入业务规则。用关系数据库作为共享的数据存储库。是用自动化程度最高的用户界面闯进啊工具和可用的可视化编程工具。
   * **如果一个架构能够吧那些与领域相关的代码隔离出来，得到一个内聚的领域涉及，同时又使领域与系统其他部分保持松散耦合，那么这种架构业务可以支持领域设计驱动**。
* 其他的分离方式
   * **TBD**   

### Chapter 5：软件中所表示的模型
* 关联
   * 模型中每个可比案例的关联，软件中都要有同样属性的机制。
   * 使得关联更易于控制的方法
      * 规定一个遍历方向
      * 添加一个限定符，以便有效地减少多重关联
      * 消除不必要的关联
* 模式：Entity（Reference Object）
   * 一些对象主要不是由它们的属性定义的。他么实际上表示了一条“标识线”（A Thread of Identity），这条线跨越时间，而且常常经历多重不同的表示。有时，这样的对象必须与另一个具有不同属性的对象相匹配。而有时一个对象必须与具有相同属性的里一个对象区分开。错误的便是可能会破坏数据。
   * 当一个对象由其标识（而不是属性）区分时，那么在模型中应该主要通过标识来确定该对象的定义。使类定义变得简单，并集中关注生命周期的连续性和标识。定义一种区分每个对象的方式，这种方式应该与其形式和历史无关。要格外注意哪些需要通过属性来匹配对象的需求。在定义标识操作时要确保这种操作为每个对象生成唯一的结果，这可以通过附加一个保证唯一性的符号来实现。这种定义标识的方法可能来自外部，也可能是有系统创建的任意标识符，但它在模型中必须是唯一标识。模型必须定义出“符合什么条件才算是相同的事物”。
   * Entity 建模
   * 设计标识操作
* 模式：Value Object
   * 跟踪 Entity 的表示是非常重要的，但为其他对象也加上表示会影响系统性能并增加分析工作，而且会是模型变得混乱，因为所有对象看起来都是相同的。
   * 软件设计要时刻与复杂性做斗争。我们必须区别对待问题，且在真正需要的地方进行特殊处理。
   * 然而，如果仅仅吧这类对象当做没有标识的对象，那么久忽略了他们的工具价值或术语价值。事实上，这些对象尤其自己的特征，对模型也有着自己的重要意义。这些是用来描述事物的对象。
   * 当我们只关心一个模型元素的属性时，应把它归类为 Value Object。我们应该使得整个模型元素能够表示出其属性的意义，并未它提供相关的功能。 Value Object 应该是不可变的。不要为它分配任何标识，而且不要把它设计成想 Entity 那么复杂。
   * 设计 Value Object
   * 设计包含 Value Object 的关联
* 模式：Service
   * 一些领域概念不适合被建模为对象。如果勉强把这些最后那个有的领域功能归为 Entity 或 Value Object 的职责，那么不是外区了基于模型的对象的定义。就是人为地增加了一些无意义的对象。
   * 当领域中的某个重要过程或转换操作不是 Entity 或 Value Object 的自然职责时，应该在模型中添加一个作为独立接口的操作，并将其神明为 Service。定义接口时要使用模型语言，并确保操作名称是 Ubiqutous Language。此外，应该使 Service 成为无状态的。
   * Service 与孤立的领域层
   * 粒度
   * 对 Service 的访问
* 模式：Moudule（Package）
   * 每个人都会使用 Module，但却很少有人把它们当做模型中的一个成熟的组成部分。代码按照各种各样的类别进行分解，有时是按照技术架构来分割的，有时是按照开发人员的任务分工来分割的。甚至那些从事大量重构工作的开发人员也倾向于使用项目早期形成的 Module。
   * 众所周知，Module 之间应该是低耦合的，而在 Module 的内部应该是高内聚的。耦合和内聚的解释使得 Module 听上去像是一种技术指标，仿佛是根据关联和交互的分布情况来机械地判断它们。然而，Module 并不仅仅是代码的划分，而且也是概念的划分，而且也是概念的划分。一个人一次考虑的事情是有限的（因此才要低耦合）。不连贯的思想和“一锅粥”似的思想同样难于理解（因此才要高内聚）。
   * 选择能够描述系统的 Module，并使之包含一个内聚的概念集合。这通常会实现 Module 之间的低耦合，但如果效果不理想，则应寻早一种更改模式的方式来消除概念之间的耦合，或者找到一个可作为 Module 基础的概念（这个概念先前可能被忽视），基于这个概念组织的 Module 可以以一种有益的方式将元素集中到一起。找到一种低耦合的概念组织方式，从而可以相互独立地理解和分析这些概念。对模型进行精化，知道可以根据高层领域概念对模型进行划分，同时相应的代码也不会产生耦合。
   * Module 的名称应该是 Ubiqutious Language 的术语。Module 及其名称应反映出领域的深层知识。
   * 敏捷的 Module
   * 通过基础设施打包时存在的隐患
      * 除非真正有必要将代码分不到不同的服务器上，否则就把实现单一概念对象的所有代码放在同一个模块中（如果不能放在同一个对象中的话）。
      * 利用打包把领域层从其他代码中分离出来，否则就尽可能让领域开发人员自由地决定领域对象的打包方式，以便支持他们的模型和设计选择。
* 建模范式   
   * 对象范式流行的原因
   * 对象世界中的非对象
   * 在混合范式中坚持使用 Model-Driven Design
      * 当将非对象元素混合到以面向对象为主的系统中时，需要遵循以下 4 条经验
         * 1. 不要和实现范式对抗
         * 2. 把通用语言作为依靠的基础
         * 3. 不要以为依赖 UML
         * 4. 保持怀疑态度   


### Chapter 6：建模范式
* 模式：Aggregate
   * 在具有复杂关联的模型中，要想保证对象更改的一致性是很困难的。不仅互不关联的对象需要遵守一些固定规则，而且紧密关联的各族对象也要遵守一些固定规则。然而，过于谨慎的锁定机制又会导致多个用户之间毫无意义的互相干扰，从而是系统不可用。
   * 我们应该将 Entity 和 Value Object 分门别类地聚集到 Aggregate 中，并定义每个 Aggregate 的边界。在每个 Aggregate 中，选择一个 Entity 作为根，并通过跟来控制对编辑啊内其他对象的所有访问。只允许外部对象保持对跟的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。由于跟控制方文，因此不能绕过它来修改内部对象。这种设计有利于确保 Aggreagate 中的对象满足所有固定规则，也可以确保在任何状态变化时 Aggreate 作为一个整体满足固定规则。
* 模式：Factory
   * 对象的创建本身可以是一个主要操作，但被创建的对象并不适合曾单复杂的装配操作。将这些之和混在一起可能产生难以理解的左列设计。让客户直接负责创建对象回事客户的设计陷入混乱，并且破坏被装配对象或 Aggregate 的封装，而且导致客户与被创建对象的实现之间产生过于紧密的耦合。
   * 选择 Factory 及其应用位置
   * 有些情况下只需使用构造函数
      * 类是一种类型，。他不是任何相关层次结构的一部分，而且也没有通过接口实现多态性。
      * 客户关心的是实现，可能是将其作为选择 Strategy 的一种方式
      * 客户可以访问对象的所有属性，因此向客户公开的构造函数中没有嵌套的对象创建。
      * 构造并不复杂。
      * 公共构造函数必须遵守与 Factory 相同的规则：它必须是原子操作，而且要满足被创建对象的所有固定规则。
   * 固定规则的相关逻辑应放置在哪里
   * Entity Factory 与 Value Object Factory
   * 重建已存储的对象
* 模式：Repository
   * 客户需要一种有效的方式来获取对象存在的领域对象的引用。如果基础设施提供了这方面的便利，那么开发人员可能会增加很多可比案例的关联，这回是模型变得非常混乱。另一方面，开发人员可能使用查询从数据库中提取他们所需要的数据，或是直接提取具体的对象，而不是通过 Aggregate 的根来得到这些对象。这样就导致领域逻辑进入查询和客户代码中，而 Entity 和 Value Object 则变成淡村的数据容器。采用大多数处理数据库访问的技术复杂性很快就会使客户代码变得混轮，这将导致开发人员简化领域层，最终是模型变得无关紧要。
   * 在所有的持久化对象中，有一小部分必须通过基于对象属性的搜索来全局访问。当很难通过便利方式来访问某些 Aggreate 根的时候，就需要使用这种方式。它们通常采是 Entity，有时是具有复杂内部结构的 Value Object，还可能是枚举 Value。而前天对象则不宜使用这种访问方式，因为这会混淆它们之间的重要区别。随意的数据库查询会破坏领域对象的封装和 Aggregate。技术基础设施和数据库访问机制的暴露会增加客户的复杂度，并妨碍模型驱动的设计。
   * Repository 查询
   * 客户代码可以忽略 Repository 的实现，但开发人员不能忽略
   * Repository 的实现
      * 对类型进行抽象
      * 充分利用与客户解耦的优点
      * 将事务的控制权留给客户
   * 在框架内工作
   * Repository 与 Factory 的关系
      * Factory 负责创造新对象
      * Repository 负责查找已有对象
* 为关系数据库设置对象

### Chapter 7：使用语言：一个扩展的示例

## 第三部分：通过重构来加深理解

### Chapter 8：突破
* 重构的投入与回报并非呈线性关系。
   * 小的改进可以防止系统退化。
   * 涌现。
* 不同的约束往往会导致不同的结果和设计。   

### Chapter 9：将隐式概念变为显示概念
* 若开发人员识别出设计中隐含的某个概念或是在讨论中受到启发而发现一个概念时，就会对领域模型和相应的代码进行许多转换，在模型中加入一个或多个对象或关系，从而将此类概念显示地表达出来。
* 概念挖掘
   * 1. 倾听语言
      * 倾听领域专家使用的语言。有没有一些属于能够简介地表达出复杂的概念？他们有没有纠正过你使用的词（也许是很委婉的提醒）？当你使用某个特定的词语时，他们脸上是否已经不再流露出迷惑的表情？这些都暗示了某个概念也许可以改进模型。
   * 2. 检查不足之处
   * 3. 思考矛盾之处
   * 4. 查阅书籍
   * 5. 尝试，再尝试
* 如何为那些不太明显的概念建模
   * 显示约束
   * 将过程建模为对象
   * 模式（Specification）
      * 业务规则通常不适合作为 Entity 或 Value Object 的职责，而且规则的变化和组合也会掩盖领域对象的基本含义。但是将规则移出领域层的结果会更糟糕，因为这样一来，领域代码就不再表达模型了。
      * 逻辑变成提供了一种概念，即“谓词”这种可分离、可组合的规则对象，但是要把这种概念用对象完全实现是很麻烦的。同时，这种概念过于通用，在表达设计意图方面，他的针对性不如专门的设计那么好。
      * 为特殊摸底创建谓词形式的显示 Value Object。Specification 就是一个谓词，可用来确定对象是否满足某些标准。
   * Specification 的应用和实现
      * Specification 最有价值的地方在于它可以将看起来完全不同的应用功能统一起来。
      * 应用
         * 验证：验证对象，检查它是否能满足某些需求或者是否已经为实现某个目标做好了准备。
         * 选择：从集合中选择一个对象。
         * 根据要求来创建：指定在粗昂建新对象时必须满足某种需求。
   * 通过可工作的模型来摆脱开发僵局。
      * 

### Chapter 10：柔性设计
* 柔性设计（supple design）
   * 定义：为了是项目能够随着开发工作的进行加速前进，而不会由于他自己的老化停滞不前，设计必须要让人们乐于使用，而且易于做出修改。
* 小心过度设计（overengineering）
* 模式：Intention-Revealing Interfaces
   * 在命名类和操作是需要描述它们的效果和目的，而不要表露他们是通过何种方式达到目的的，这样可以是客户开发人员不必去了解内部细节。这些名称应该与 Ubiquitous Language 保持一致，一遍团队成员可以迅速推断出它们的意义。在创建一个行为之前先为它编写一个测试，这样可以促使你站在客户开发人员的角度上来思考它。
* 模式：Side-Effect-Free Function
   * 多个对象的相互作用或计算的组合所产生的结果是很难预测的。开发人员在调用一个操作时，为了预测操作的结果，必须理解它的实现以及它所调用的其他方法的实现。如果开发人员不得不“揭开接口的面纱”，那么接口的抽象作用就收到了限制。如果没有了可以安全地预见到结果的抽象，开发人员就必须限制“组合爆炸”，这就限制了系统的丰富性。
   * 极可能吧程序的逻辑放到函数中，因为函数只返回结果而不产生明显的副作用。严格地吧命令（引起明显的状态改变的方法）隔离刀不返回领域信息的、非常简单的操作中。当发现了一个非常适合承担复杂逻辑职责的概念时，就可以吧这个复杂逻辑移到 Value Object 中，这样可以进一步控制副作用。
* 模式：Assertion
   * 如果操作的副作用仅仅是由它们的实现隐藏定义的，那么在一个具有大量相互调用关系中，起因和结果会变得一团糟。理解程序的唯一方法就是沿着分支路径来跟踪程序的执行。封装完全失去了价值。跟踪具体的执行也使抽象失去了意义。
   * 把操作的后置条件和类以及 Aggregate 的固定规则表述清楚，如果你的编程语言中不能直接编写 Assertion，那么久把它们编写成自动的单元测试。还可以把它们写到文档或图中。
   * 寻找在概念上内聚的模型，以便使开发人员更容易推断出预期的 Assertion，从而加快学习，从而避免代码矛盾。
* 模式：Conceptual Contour
   * 如果把模型或设计的所有元素都放在一个整体的大结构中，那么它们的功能就会发生重复。外部接口无法给出客户可能关心的全部信息。由于不同的概念被混合在一起，它们的意义变得很难理解。
   * 另一方面，把类和方法分解开可能是毫无意义的，这会使客户更复杂，破事客户对象去理解各个细微部分是如何组合在一起的。更糟糕的是，有的概念可能会完全丢失。铀原子的一半不是铀。而且，粒度的大小并不是唯一要考虑的问题，我们还要考虑粒度是在哪种场合下使用的。
   * 把设计元素（操作、接口、类和 Aggregate）分解为内聚的单元，在这个过程中，你对领域中的一切重要划分的直观认识也要考虑在内。在连续的重构股哟城中观察发生变化和保证稳定的规律性，并寻早能够解释这些变化模式的底层 Conceptual Contour。使模型与领域中那些一致的方面（正式这些方面使得领域成为一个有用的知识体系）相匹配。
* 模式：Standalone Class
   * 即使是在 Moudle 内部，设计也会随着依赖关系的增加而变得越来越难以理解。这加重了我们的思考负担，从而限制了开发人员能处理的实际复杂度。隐式概念比显示引用增加的负担更大。
   * 低耦合是对象设计的一个基本要素。尽一切可能保持低耦合。吧其他所有无关概念提取到对象之外。这样类就变得完全独立了，这就使得我们可以单独研究和理解它。每个这样的独立类都极大地减轻了因理解 Module 而带来的负担。
* 模式：Closure of Operation
   * 闭合操作
   * 大部分引起我们兴趣的对象所产生的行为仅用基本类型是无法描述的。
   * 在适当的情况下，在定义操作时让他的返回类型与其参数的类型相同。如果实现着的状态在计算中会被用到，那么实现着实际上就是操作的一个参数，因此参数和返回值应该与实现着有相同的类型。这样的操作就是在该类型的实例集合中的必和操作。闭合擦偶偶提供了一个高层接口，同时又不会引入对其他概念的任何依赖。
* 声明式设计
   * 领域特定语言
* 声明式设计风格
   * 用声明式的风格来扩展 Specification
* 切入问题的角度
   * 分割子领域
   * 尽可能利用已有的形式   

### Chapter 11：应用分析模式
* 分析模式的最大作用是是借鉴其他项目的经验，把那些项目中有关设计方向和实现结果的广泛讨论与当前的模型的理解结合起来。
* **他山之石可以攻玉**

### Chapter 12：将设计模式应用与模型
* 模式：Strategy（也称为 Policy）
   * 领域模型包含了一些并非用于解决技术问题的过程，将它们包含景来是因为对处理领域具有实际的价值。当必须从多个过程中进行选择时，选择的复杂性再加上多个过程本身的复杂性会使局面失去控制。
   * 我们需要把过程中的易变部分提取到模型的一个单独的“策略”对象中，将规则与它所控制的行为分开。按照 Strategy 设计模式来实现规则或可替换的过程。策略对象的多个版本表示了完成过程的不同方式。
* 模式：Composite
   * 当嵌套容器的关联性没有在模型中反映出来时，公共行为必然会在层次结构的每一层重复出现，而且嵌套也变得僵化（例如，容器通常不能包含同一层中的其他容器，而且嵌套的层数也是固定的）。客户必须通过不同的接口来处理层次结构中的不同层，尽管这些层在概念上可能没有区别。通过层次结构来递归地手机信息也变得非常复杂。
   * 定义一个吧 Composite 的所有成员都包含在内的抽象烈性。在容器上实现那些查询信息的方法时，这些方法返回有容器的内容所汇总的信息。而“叶”节点则基于它们自己的值来实现这些方法。客户只需要使用抽象类型，而无需区分“叶”和容器。   

### Chapter 13：通过重构得到更深层的理解
* 重要的关注点：
   * 1. 以领域为本
   * 2. 用一种不同的方式来看待事物
   * 3. 始终坚持与领域专家对话
* 开始重构：任何时候
* 探索团队：
   * 自主决定
   * 注意范围和休息
   * 练习使用 Ubiquitous Language
* 借鉴先前的经验
* 针对开发人员的设计
   * 柔性设计
* 重构的时机
   * 设计没有表达出团队对领域的最新理解
   * 重要的概念被隐藏在设计中了
   * 发现一个嫩巩固领某个重要的设计部分变得更灵活的机会
* 危机就是机遇         

## 第四部分：战略设计   

### Chapter 14：保持模型的完整性
* 大型系统领域模型的完全统一既不可行，也不划算。
* 模型完整性导航图
   * Bounded Context
      * --通过它保持了模型统一--> CI（Continous Integration）
      * --名称输入--> Ubiquitous Language
      * --评估/概要了解与上下文图的关系--> Context Map
         * --通过它把类似上往下文重叠在一起--> Sharead Kernel
         * --把类似上下文作为 Customer/Suppler Teams 关联到一起-->  Customer/Supplier Teams 
         * --单项重叠（作为“跟随者”）--> Conformist
         * --通过它支持多个客户--> Open Host Service
            * --形式化为--> Published Language
         * --团队自由工作--> Separate Ways
         * --单向转换并隔离--> Anticorruption Layer、
* 模式：Bounded Context
   * 任何大型项目都会存在多个模型。而当机遇不同模型的代码被组合到一起后，软件就会出现bug、变得不可靠和难以理解。团队成员之间的沟通会变得混乱。人们往往弄不清楚一个模型不应该在那个上下文中使用。
   * 明确地定义模型所应用的上下文。根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置模型的边界。在这些边界中严格保持模型的一致性，而不要受到边界之外的问题的干扰和混淆。
   * 识别 Bounded Context 中的不一致
* 模式：Continuous Integration
   * 建立一个把所有代码和其他实现工件频繁地合并到一起的过程，并通过自动化测试来快速查明模型的分裂问题。严格坚持使用 Ubiquitous Language，以便在不同人的头脑中演变出不同的概念时，使所有人对模型都能达成一个共识。
* 模式：Context Map
   * 其他对团队中的人员并不是十分清楚 Context 的边界，他们会不知不觉地做出一些修改，从而是边界变得模糊或者互联变得复杂。当不同的上下文必须互相连接时，他们可能会互相重叠。
   * 识别在项目中起作用的每个模型，并定义其 Bounded Context。这包括非面向对象子系统的隐含模型。为每个 Bounded Context 命名，并把名称添加到 Ubiquitous Language 中。**创造新的概念**   
   * 描述模型之间的联系点，明确所有通信需要的转换，并突出任何共享的内容。
   * 先将当前的情况描绘出来。以后再做改变。
   * 测试 Context 的边界
   * Context Map 的组合和文档化
      * Bounded Context 应该有名称，以便可以讨论他们。 
      * 每个人都应该知道边界在哪里，而且应该嫩巩固分辨出任何代码段的 Context，或者任何情况的 Context。
* Bounded Context 之间的关系
* 模式：Shared Kernel
   * 当不同的团队开发一些紧密相关的应用程序时，如果团队之间不进行协调，及时短时间内能够取得快速进展，但他们开发出的产品可能无法结合到一起。最后可能不得不耗费大量精力在转化层上，并且频繁进行改动，不如一开始就使用 Continuous Integration 那么省心省力，同时这也造成重复工作，并且无法实现公共的 Ubiquitous Language 所带来的好处。
   * 从领域模型中选出两个团队都同意共享的一个自己。当然，除了这个模型子集之外，还包括与该模型部分相关的代码自己，或数据库设计的子集。这部分明确共享的内容具有特殊的地位，一个团队在没与另一个团队商量的情况下不应擅自更改它。
   * 功能系统要经常进行集成，但集成的频率应该比团队中 Continuous Integration 的频率低一些。在进行这些集成的时候，两个团队都要运行测试。
* 模式：Customer/Supplier Development Team
   * 在两个团队之间建立一种明确地的客户/供应商关系。在计划会议中，下游团队相当于上游团队的客户。根据下游团队的需求来协商需要执行的任务并未这些任务做预算，以便每个人都知道双方的约定和进度。   
   * 两个团队共同开发自动化验收测试，用来验证预期的接口。吧这些测试添加到上有团队的测试陶建忠，一遍作为其 CI 的一部分来运行。这些测试是上游团队在做出修改是不必担心对下游团队产生副作用。
* 模式：Conformist
   * 当两个开发团队具有上/下游关系时，如果上游团队没有动力来满足下游团队的需求，那么下有团队将无能为力。处于利他主义的考虑，上游开发人员可能会做出承诺，但他们可能不会旅行承诺。校友团队处于良好的医院会相信这些承诺，从而根据一些永远不会实现的特性来定制计划。下游项目只能被搁置，直到团队最终学会利用现有额天剑自力更生为止。下游团队不会得到根据他们的需求而量身定做的接口。
   * 通过严格遵循上有团队的模型，可以消除在 Bounded Context 之间进行转换的复杂性。尽管这回先知下游设计人员的风格，而且可能不会得到理想的应用程序模型，但选择 Conformity 模式可以极大地简化集成。此外，这样可以与供应商团队共享 Ubiquitous Language。供应商处于统治地位，因此最好是沟通变得容易。他们从利他主义的角度出发，会与你分享信息。
* 模式：Anticorruption Layer
   * 当正在构建的新体统与另一个系统的接口很大时，为了克服连接两个模型而带来的款南，新模型所表达的意图坑你会被完全改变，最终导致它被修改得像是另一个模型了（以一种特定的风格）。遗留系统的模型通常很弱。及时对于那些模型开发的很多的例外情况，它们可能也不符合当前项目的需要。然而，集成遗留系统仍然具有很大价值，而且有时候还是绝对必要的。
   * 创建一个隔离层，以便根据客户自己的领域模型来为自己提供相关功能。这个层通过以另一个系统现有的接口与其进行对话，而只需要对那个系统做出很少的修改，甚至无需修改。在内部，这个曾在两个模型之间进行必要的双向转换。
   * 设计 Anticorruption Layer 接口
   * 实现 Anticorruption Layer
      * Facade VS. Adapter
* 模式：Separate Way
   * 声明一个与其他上下文毫无关联的 Bounded Context，使开发人员能够在这个小范围内找到简单、专用的解决方案。
* 模式：Open Host Service
   * 当一个子系统必须与大量其他系统进行集成时，为每个集成都指定一个转换成可能会减慢团队的工作速度。需要维护的东西会越来越多，而且进行修改的时候担心的事情也会越来越多。
   * 定义一个协议，把你的子系统作为一组 Service 供其他系统访问。开放这个系统，一遍所有需要与你的子系统集成的人都可以使用它。当有新的额集成需求时，就增强并扩展这个协议，但个别团队的特殊去求除外。满足这种特殊需求除外。满足这种特殊需要的方法是使用一次性的转换器来阔爱从协议，一遍是共享协议简单且内聚。
* 模式：Published Language
   * 把一个良好文档化的、能够表达出所需领域信息的共享语言作为公共的通信媒介，必要时在其他信息与该语言之间进行转化。
* “大象” 的统一
* 选择你的模型上线策略
   * 团队决策或更高层决策
   * 置身上下文中
   * 转换边界
   * 接受那些我们无法更改的事物：描述外部系统
   * 与外部系统的关系
   * 设计中的系统
   * 用不同的模型满足需要
   * 部署
   * 权衡
   * 当项目正在进行时
* 转换
   * 合并 Context：Separate Way -> Shared Kernel
   * 合并 Context：Shared Kernel -> Continuous Integration
   * 逐步淘汰遗留系统
   * Open host service -> Published Language   

### Chapter 15：精炼
* Core Domain
   * 对模型进行提炼。找到 Core Domain 并提供一种易于区分的方法吧它与那些欺负到作用的模型和代码分开。最有价值和最专业的概念要轮廓分明。尽量压缩 Core Domain。
   * 让最有才能的人来开发 Core Domain，并据此要求进行相应的招聘。在 Core  Domain 中努力开发能够确保实现系统蓝图的深层模型和柔性设计。仔细判断任何其他部分的投入，看它是否能够支持这个提炼出来的 Core。
   * 选择核心
   * 工作分配
* 精炼的逐步提升
* 模式：Generic Subdomain
   * 识别出那些与项目意图无关的内聚子领域。把这些子领域的通用模型提取出来，并放到单独的 Moudle 中。任何专有的东西都不应该放在这些模型中。
   * 把他们分离出来以后，在继续开发的过程中，他们的优先级应低于 Core Domain 的优先级。并且不要分派核心开发人员来完成这些任务（因为他们很好能够从这些任务中获得领域知识）。此外，还可以考虑为这些 Generic Subdomain 使用线程的解决方案或“公开发布的模型”（Published Model）。
      * 选择现成的的解决方法
      * 选择公开发布的设计或模型
      * 选择把实现外包出去
      * 选择内部实现
   * 通用不等于可重用
   * 项目风险管理
   * 模式：Domain Vision Stratement
* 模式：Highlighted Core
   * 精炼文档
   * 标明 Core
   * 把精炼文档作为过程工具
* 模式：Cohesive Mechanism（内聚机制）
   * 把概念上的 Cohesive Mechanism（内聚机制）分离到衣蛾单据的轻量级架构中。要特别注意共识或那些有完备文档的算法。用一个 Intention-Revealing Interface 来暴露这个框架的功能。现在，领域中的其他元素就可以只专注于如何表达问题（做什么）了，而吧解决方案的复杂细节（如何做）转移给了框架。
   * Mechanism 是 core domain 一部分
* 通过精炼得到声明式风格
* 模式：Segregated core
   * 对模型进行重构，吧核心概念从支持性元素中分离出来，并增强 core 的内聚性，同时减少它与其他代码的耦合。把所有通过元素或支持性元素提取到其他对象中，并把这些对象放到其他的包中 —— 即使这些吧一些紧密耦合的元素分开。
   * 得到 Segregated core 的一般步骤
      * 1. 识别出一个 core 子领域
      * 2. 把相关的类移到新的 module 中，并根据与这些类有关的 概念为模块命名。
      * 3. 对代码进行重构，把那些不直接表示概念的数据和功能分离出来。
      * 4. 对新的 Segregated core module 进行重构
      * 5. 对另一个 core 子领域重复这个过程，知道完成 segregated core 的工作。
   * 创建 Segregated core module 的代价
   * 不断发展演变的团队决策
* 模式：abstrct core
   * 把模型中最基本的概念识别出来，并分离到不同的类、抽象类或接口中。设计这个抽象模型，使之能够表传达出重要组件之间的大部分交互。把这个完整的抽象模型放到它自己的 module 中，而专用详细的实现类则留在由子领域定义的 module 中。
* 深层模型精炼
   * 尽管任何带来深层模型的突破都有价值，但只有 core domain 的突破才能改变整个项目的轨道。
* 选择重构目标   

### Chapter 16：大型结构
* 设计一种应用于真个系统的规则（或角色和关系）模式，使人们可以通过它在一定程度上了解各个部分在整体中所处的位置（及时是在不知道哥哥部分的详细职责的情况下）。
* 模式：Evolving order
* 模式：System metaphor
   * 当系统的一个具体类比正好符合团队成员对系统的想想，并且能够引导他们向着一个有用的方向进行思考时，就应该吧这个类比用作一种大型结构。
* 模式：Responsibility Layer
   * 如果每个对象的职责都是人为分配的，将没有统一的指导原则和一致性，也无法把领域作为一个整体来处理。为了保持大模型的一致性，有必要在职责分配上实施一定的结构化控制。
   * 注意观察模型中的概念依赖性，以及领域中不同部分的变化频率和变化原因。如果在领域中发现了自然的层次结构，就把它们转换为宽泛的抽象职责。这些职责应该描述系统的高层目的和设计。对模型进行重构，使得每个领域对象、aggregate 和 module 的职责都清晰地定位于一个职责层当中。
   * 选择适当的层
      * 场景描述
      * 概念依赖性
      * coneceptual contour
      * 潜能层
      * 作业层
      * 决策支持层
      * 策略层
      * 承诺层
* 模式：Knowledge level  
   * 创建一组不同的对象，用他们来描述和约束基本模型的结构和行为。吧这些对象分为两个级别，一个是非常具体的级别，另一个级别则提供了一些可供用户或超级用户定制的规则和知识。
* 模式：Pluggable component framework
   * 从接口和交互中提炼出一个 abstract core ， 并创建一个框架，这个框架要允许这些接口的各种不同实现被自由替换。同样，无论是什么应用传给程序，只要它严格地通过 abstract core 的接口进行操作，那么久可以允许它使用这些组件。
* 结构应该有一种什么样的约束
* 通过重构得到更适当的结构
   * 最小化
   * 沟通和自律
   * 通过重构得到柔性设计
   * 通过精炼可以减轻负担    

### Chapter 17：领域驱动设计的综合运用
* 把大型结构和 Bounded Context 结合起来使用
* 把大型结构和精炼结合起来使用
* 首先评估
   * 1. 画出 Context map
   * 2. 主要项目上的语言使用
   * 3. 理解重点所在
   * 4. 项目所采用的技术是遵循 model-driven design
   * 5. 团队开发人员是否具备必要的技能
   * 6. 开发人员是否了解领域知识
* 由谁制定策略
   * 从应用程序开发自动得出的结构
   * 以客户为中心的架构团队
* 制定战略设计决策的6 个要点
   * 决策必须传达到整个团队
   * 决策搓成必须首届反馈意见
   * 计划必须允许演变
   * 架构团队不必把所有最好、最崇明的人员都吸收进来
   * 战略设计需要遵守简约和谦逊的原则
   * 技术框架同样如此
   * 注意总体规划

