微服务设计

***Chapter1 微服务***

1.1 什么是微服务
   * 微服务就是一些协同工作的小而自治的服务
      * 很小，专注于一件事情（内聚）
      * 自治性

1.2 主要好处
   * 技术异构性
   * 弹性：舱壁，单个外部服务单个线程池
   * 扩展
   * 简化部署
   * 与组织结构相匹配
   * 可组合性
   * 对可替代性的优化

1.3 面向服务的架构
   * SOA（Service-Oriented Architecture）   

1.4 其他分解技术
   * 共享库
   * 模块

1.5 没有银弹


***Chapter2 演化式架构师***

2.1 不准确的比较   
   * 你总提及的那个词，它的含义与你想表达的意思并不一样。

2.2 架构师的演化视角

2.3 分区

2.4 一个原则性的方法
   * 规则对于智者来说是指导，对于愚者来说是遵从
   * 战略目标：愿景是什么，会发生什么变化
   * 原则：为了和目标保持一致，制定的规则
   * 实践：实践应巩固原则
   * 讲原则和实践相结合：
   * 真实世界的例子

2.5 要求的标准
   * 监控
   * 接口
   * 架构安全性

2.6 代码治理
   * 范例：编写文档
   * 剪裁服务代码模板

2.7 技术债务

2.8 例外管理

2.9 集中治理和领导

2.10 建设团队

2.11 演进式架构师的职责
   * 愿景
   * 同理心：理解所做决定对客户和同事带来的影响
   * 合作：和尽量多的同时进行沟通，从而更好地对愿景进行定义、修订以及执行   
   * 适应性：确保在你的客户和组织需要的时候调整技术愿景
   * 自治性：在标准化和团队自治之间寻找一个正确的平衡点
   * 治理：却表系统按照技术愿景的要求实现

***Chapter3：如何构建微服务***

3.1 MusicCorp 

3.2 什么样的服务是好服务
   * 松耦合：一个模块的改动不需要另一个模块的改动
   * 高内聚：将所有相关的行为聚集在一起，把不想关的行为放在别处

3.3 界限上下文
   * 一个由显示边界界定的职责
   * 共享的隐藏模型
   * 模块和服务
   * 过早划分

3.4 业务功能

3.5 逐步划分上下文

3.6 关于业务概念的沟通

3.7 技术边界

***Chapter 4：集成***

4.1 寻找理想的集成技术
   * 避免破坏性修改
   * 保证API的技术无关性
   * 使你的服务易于消费方s会用
   * 隐藏内部实现细节

4.2 为用户创建接口

4.3 共享数据库
   * 需要避免

4.4 同步与异步
   * 请求相应或者基于事件

4.5 编排与协同
   * 同步的编排：中心大脑控制并驱动整个流程
      * RPC or REST
   * 异步的协同：    

4.6 远程过程调用
   * 技术的耦合
      * RPC中的Java RMI与特定的平台绑定     
   * 本地调用和远程调用并不相同
      * ==网络是不可靠的==
   * 脆弱性
      * rpc很糟糕么？ 也不尽然

4.7 REST
   * REST和HTTP
   * 超媒体作为程序状态的引擎
   * JSON、XML还是其他
   * 留心过多的约定
   * 基于HTTP的REST的缺点
      * 性能

4.8 实现基于事件的异步协作方式
   * 技术选择：MQ
   * 异步架构的复杂性

4.9 服务即状态机

4.10 响应式扩展
  
4.11 微服务世界中的DRY和代码重用的危险
   * 避免过度耦合

4.12 按引用访问

4.13 版本管理
   * 尽可能推迟
   * 及早发现破坏性修改
   * 使用语义化的版本管理
   * 不同的接口共存
   * 同时使用多个版本的服务

4.14 用户界面
   * 走向数字化
   * 约束
   * API组合
   * UI的片段组合
   * 为前端服务的后端
   * 一种混合方式

4.15 与第三方软件集成
   * 缺乏控制
   * 定制化
   * 意大利面式的集成
   * 在自己可控的平台进行定制化
   * 绞杀者模式：捕获并拦截对于老系统的调用

***Chapter5：分解单块系统***

5.1 关节是接缝
   * 界限上下文就是好的接缝

5.2 分解MusicCorp

5.3 分解单块系统的原因
   * 改变的速度
   * 团队结构
   * 安全
   * 技术

5.4 杂乱的依赖

5.5 数据库

5.6 找到问题的关键

5.7 例子：打破外键关系

5.8 例子：共性静态数据

5.9 共享数据

5.10 例子：共享表
   * 分离共享表

5.11 重构数据库
   * 实施分离
      * 逐步对服务进行分离
         1. 单一表结构
         1. 分离表结构
         1. 把应用程序分成两个服务   

5.12 事务边界
   * 再试一次
   * 终止整个操作
   * 分布式事务
   * 应该怎么办？？？

5.13 报表

5.14 报表数据库

5.15 通过服务调用来获取数据

5.16 数据导出

5.17 事件数据导出   

5.18 数据导出的备份

5.19 走向实时

5.20 修改的代价

5.21 修改的原因：小服务也是有大服务发展而来

***Chapter6：部署***

6.1 持续集成简介
   * 你真的在做CI么
      * 你是否每天签入代码到主线？
      * 你是否有一组测试来验证修改
      * 当构建失败之后，团队是否吧秀谷CI当做第一优先级的事情

6.2 把持续集成映射到微服务
   * 每个微服务一个构建：单个代码 => CI => service

6.3 构建流水线和持续交付
   * 编译以及快速测试
   * 耗时测试
   * 用户验收测试
   * 性能测试
   * 生产环境

6.4 平台特定的构建物

6.5 操作系统构建物

6.6 定制化镜像
   * 将镜像作为构建物
   * 不可变服务武器：host上的服务配置不可更改

6.7 环境

6.8 服务配置

6.9 服务与逐级之间的映射
   * 单主机多服务
   * 应用程序容器
   * 每个主机一个服务
   * 平台即服务

6.10 自动化

6.11 从物理机到虚拟机 
   * 传统的虚拟化技术
      * hypervisor
   * Vagrant
   * Linux容器
   * Docker

6.12 一个部署接口

***Chapter7 测试***

7.1 测试类型
   * 面向技术：单元测试 + 非功能性测试（响应时间、可扩展性、性能、安全）
   * 支持团队：单元测试 + 验收测试
   * 面向业务：验收测试 + 探索性测试（可用性测试）
   * 评价产品：探索性测试 + 非功能性测试
  
7.2 测试范围
   * 单元测试
   * 服务测试
   * 端到端测试
   * 权衡
   * 比例

7.3 实现服务测试
   * mock还是打桩
   * 智能的打桩服务
    
7.4 微妙的端到端测试

7.5 端到端测试的缺点

7.6 脆弱的测试
   * 谁来写这些测试
   * 测试多长时间
   * 大量的堆积
   * 元版本

7.7 测试场景而不是故事

7.8 拯救我们的消费者驱动测试
   * CDC： Consumer-Driven Contract 消费者驱动的契约
   * Pact
   * 关于沟通

7.9 还应该使用端到端测试不？ 

7.10 部署后再测试
   * 区分部署和上线
   * 金丝雀发布
   * 平均修复时间胜过平均故障间隔时间

7.11 跨功能的测试
   * 性能测试         

***Chapter8：监控***

8.1 单一服务，单一服务器

8.2 单一服务，多个服务器

8.3 多个服务，多个服务器

8.4 日志，日志，更多的日志

8.5 多个服务的指标跟中

8.6 服务指标

8.7 综合监控  
   * 实现语义监控

8.8 关联标识

8.9 级联
   * 级联故障特别危险，雪崩   

8.10 标准化

8.11 考虑受众
   * 他们现在需要知道什么
   * 他们之后想要知道什么
   * 他们如何消费数据 

8.12 未来

***Chapter 9：安全***

9.1 身份验证和授权
   * 常见的单点登录SSO实现：SAML，OpenID Connet
   * 单点登录网关
   * 细粒度的授权

9.2 服务间的身份验证和授权
   * 在边界内允许一切
   * HTTP(S)基本身份验证
   * 使用SMAL或OpendID Connect
   * 客户端整数
   * HTTP之上的HMAC（Hash-based Message Authentication Code）
   * API 秘钥

9.3 静态数据安全
   * 使用总所周知的加密算法
   * 一切皆与秘钥相关
   * 选择你的目标
   * 按需解密
   * 加密备份

9.4 深度防御
   * 防火墙
   * 日志
   * 入侵检测（和预防）系统
   * 网络隔离
   * 操作系统
 
9.5 一个例子

9.6 保持节俭

9.7 人的因素

9.8 黄金法则

9.9 內建安全

9.10 外部验证


***Chapter10：康威定律和系统设计***

任何组织在涉及一套系统（广义概念上的系统）时， 所交付的设计方案在结构上都与该组织的沟通结构保持一致。

10.1 证据
   * 松耦合组织和紧耦合组织
   * Windows Vista

10.2 Netflix和Amazon
   * 两个披萨团队：没有一个团队应该大到两个披萨不够吃

10.3 我们可以做什么

10.4 适应沟通途径

1.5 服务所有权

10.6 共性服务的原因
   * 难以分割
   * 特性团队
   * 交付瓶颈

10.7 内部开源
   * 守护者的角色
   * 成熟
   * 工具

10.8 界限上下文和团队结构

10.9 孤儿服务

10.10 研究案例

10.11 反向的康威定律
   * 架构反作用于组织？

10.12 人       


***Chapter 11：规模化微服务***

11.1 故障无处不在
   * 分布式故障

11.2 多少是太多
   * 响应时间/延迟
   * 可用性
   * 数据持久性

11.3 功能降级

11.4 架构性安全措施

11.5 反脆弱的组织
   * 超时
   * 断路器
   * 舱壁
   * 隔离

11.6 幂等

11.7 扩展
   * 更强大的主机（垂直扩展）      
   * 拆分负载
   * 分散风险
   * 负载均衡
   * 基于worker的系统
   * 重新设计

11.8 扩展数据库
   * 服务的可用性和数据的持久性
   * 扩展读取
   * 扩展写操作
   * 共享数据库基础
   * CQRS（Command-Query Responsibility Segregation，命令查询职责分离）

11.9 缓存
   * 客户端、代理和服务器缓存
   * HTTP缓存
   * 为写使用缓存
   * 为弹性使用缓存
   * 隐藏源服务
   * 保持简单
   * 缓存中毒：一个警示
      * 缓存一直不过期，多级cache（缓存时间叠加）

11.10 自动伸缩

11.11 CAP定理
   * 在分布式系统中三方面需要权衡：一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance），这个定理证明只能保证两个
   * 牺牲一致性： AP系统
      * 最终一致性
   * 牺牲可用性：CP系统
      * 银行
   * 牺牲分区容忍性：CP系统
      * 在分布式系统中不存在
   * AP还是CP
      * 具体业务具体权衡
   * 这不是全部或全不
   * 真是世界

11.12 服务发现
   * DNS

11.13 动态服务注册
   * zookeeper
   * Consul
   * Eureka
   * ETCD
   * 构造你自己的系统
   * 别忘了人

11.14 文档服务
   * Swagger
   * HAL和HAL浏览器

11.15 自描述系统


***Chapter12 总结***

12.1 微服务的原则
   * 围绕业务概念建模
   * 接受自动化文化
   * 隐藏内部实现细节
   * 让一切去中心化
   * 可独立部署
   * 隔离失败
   * 高度客观察

12.2 什么时候你不应该使用微服务
   * 从头开发 + 新领域
      * 首先构建单块系统，
      * 当稳定之后再进行拆分
                    
