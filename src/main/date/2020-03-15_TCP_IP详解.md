# TCP/IP 详解
### [Book Online](http://www.52im.net/topic-tcpipvol1.html)

### Chapter 1：概述
* 分层
   * 1. 应用层：Telent、FTP 和 e-mail
   * 2. 传输层：TCP 和 UDP
   * 3. 网络层：IP、ICMP 和 IGMP
   * 4. 链路层：设备驱动程序以及接口卡

* 一个互联网就是一组通过相同协议簇互联在一起的网络。
* 五类互联网地址：A、B、C、D 和 E
* 域名系统：DNS
* 封装
   * 逐层封装，逐层解封装
* 客户服务器模型
* 端口号
* RFC：Request For Comment

### Chapter 2：链路层
* 尾部封装
* SLIP：串行线路 IP
* 压缩的 SLIP
* PPP： 点对点协议
* 环回地址：127.X.X.X
* 最大传输单元 MTU
* 路径 MTU
   * 两台通信主机路径中的的最小 MTU
   

### Chapter 3：IP 网际协议
* IP 提供尽力而为的传输服务
* TTL 设置了数据可以经过的最大路由数
* IP 路由选择
   * 路由表
      * 1. 目的 IP 地址
      * 2. 下一站（下一跳）路由的 IP 地址
      * 3. 为数据报文的传输指定一个网络接口
   * IP 路由主要功能
      * 1. 搜索路由表，寻找能够与目的 IP 地址完全匹配的表目
      * 2. 搜索路由表，寻找能与目的网络号相匹配的理由表
      * 3. 搜索路由表，寻找标为 “默认（Default）”的表目
* 校验和作为非常重要的手段
   * 网络协议
   * 应用协议        

### Chapter 4 ARP：地址解析协议
* ARP ： 将 32 位的 IP 地址解析位 48 位的以太网地址
* ARP 高速缓存
   * 一般缓存 20 min
* 请求广播，应答单播
* 点对点链路不适用 ARP

### Chapter 5 RARP：逆地址解析协议
* 无盘系统
* 将以太网地址转换为 IP 地址
* 请求广播，应答单播

### Chapter 6 ICMP：Internet 控制报文协议
* ICMP 报文分类
   * 请求
   * 差错
* 一个 ICMP 端口不可达是立即返回的


### Chapter 7：Ping 程序
* 该程序发送一份 ICPM 回显请求报文给主机，并等待返回 ICMP 回显应答。
* IP 记录路由选项
* IP 时间戳选项
* 利用 ICMP 回显请求和回显应答报文，不经过 TCP/UDP。

### Chapter 8：Traceroute 程序
* 程序发送一份 UDP 数据报给目的主机，但它选择一个不可能的值作为 UDP 端口号（大于 30000），使目的主机的任何一个应用程序都不可能使用该端口。
   * 开始发送 TTL 字段为 1 的 UDP 数据报，然后将 TTL 字段每次加1， 以确定路径中的每个路由器。
   * 每个路由器在丢弃 UDP 数据报时都返回一个 ICMP 超时报文，而最终目的主机则产生一个 ICMP 端口不可达的报文。
   * 目的主机的 UDP 模块会产生一份“端口不可达“错误。
   

### Chapter 9：IP 选路
* ICMP 重定向差错
   * 一般用来将具有很少选路信息的主机逐渐建立更完善的路由表。

### Chapter 10：动态选路协议
* Internet 是以一组自治系统（AS，Autonomous System）的方式组织的。   
* 两种基本的选路协议
   * 1. 内部网关协议（IGP）：同一套自治统各路由器之间的
      * RIP：RIP 包含在 UDP 数据报中。没有子网概念。 
      * OSPF：使用 IP 协议，多播。
      * 
   * 2. 外部网关协议（EGP）：不同自治系统内路由器。
      * BGP：使用 TCP 作为传输协议

### Chapter 11 UDP：用户数据报协议
* 校验和是简单的 16 bit 和，它们检测不出交换两个 16 bit 的差错。
* IP 分片
   * IP 将 MTU 与数据报文长度进行比较，如果需要则进行分片。
   * 分片可以发生在原始发送端上，也可以发生在中间的路由器。
   * IP 层本身没有超时重传机制。
   * IP 每隔 30是假将 DF 比特设置，以检查路径 MTU 是否增大了。
* 最大 UDP 数据报长度
   * 一般 512 字节，或者更小
* ICMP 源站抑制差错
   * 优于源站抑制要消耗王铎带宽，且对用社来说是一种无效而不公平的调整，因此现在人们对于源站一直差错的差错都是不支持的。   
* UPD服务器的设计
   * UDP 输入队列   

### Chapter 12：广播和多播
* 广播和多播仅用于 UDP
* ARP、RARP 是请求广播、应答单播
* FDDI 和 令牌环网络中的多播。

### Chapter 13 IGMP：Internet 组管理协议
* IGMP 协议
   * 加入一个多播组
   * IGMP 报告和查询

### Chapter 14 DNS：域名系统
* 层级结构
   * 未命名树根 ROOT
   * 顶级域
   * 第二级域
* 域名服务器高可用
   * 主备
   * 高速缓存：在域名服务器侧
* DNS
   * 根据域名查找 IP
   * 指针查询：根据 IP 查 host      
* 选择 TCP 还是 UDP
   * 响应大于 512 字节，请求段会重新使用 TCP
   * 区域传送使用 UDP，因为这里传送的数据远比一个查询或相应多得多。

### Chapter 15 TFTP：简单文件传送协议
* 最初用于引导无盘系统（通常是工作站或 X 终端）。
* TFTP 使用 UDP

### Chapter 16 BOOTP：引导程序协议
* 无盘系统引导的替代方法（替代 RARP）。


### Chapter 17：TCP 传输控制协议
* TCP 通过以下方式来提供可靠性
   * 1. 应用数据别分割成 TCP 认为最合适的数据块。
   * 2. 当 TCP 发出一个段后它将启动一个定时器，等待目的端确认这个报文段。
   * 3. 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。 这个确认不是立即发送，通常延时几分之一秒。
      * 经受延时确认。 
   * 4. TCP 将保持它的首部和数据的校验和。
      * 如果收到的段检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文。（因为源 IP 也可能被更改了）
   * 5. TCP 重新排序
   * 6. 丢弃 TCP 重复数据
   * 7. TCP 流量控制
* 四个定时器
   * 1. 重传定时器
   * 2. 2 MSL 定时器
   * 3. 坚持定时器
   * 4. KeepLive 定时器   
* 序列号用来标识从 TCP 发端向 TCP 收端发送的数据字节流，它标识在这个报文段中的第一个数据字节。 
   * ISN：Initial Sequence Number
   * 每 4ms 加一：防止在网络中被延迟的分组在以后又被传送，而导致某个链接的一方对他作错误的解释。
* TCP 可以表述为一个没有选择确认或否认的滑动窗口协议
   * TCP 缺少选择确认是因为 TCP 首部中的确认序列号标识发方已成功收到字节，单还不包含确认序号所指的字节。   
* TCP 流量控制由链接的每一段通过声明的窗口大小来提供。
* MSS：Maximum Segment Size
   * 最长报文大小，在 SYN 报文中标识。 
* 校验和覆盖了整个 TCP 报文段：TCP 首部和 TCP 数据。
* 应用 TCP 的应用
   * Telent、Rlogin、FTP 和 SMTP   

### Chapter 18：TCP 连接的建立与终止
* 建立连接协议
   * ISN ：初始同步号
   * ISN 可以看做是一个 32 比特的计数器，每 4ms 加 1.
* 断开连接协议
   * 全双工。
   * 首先执行关闭的一方将执行主动关闭。
* 建立连接超时
   * 一个滴答为 500ms
   * 内核调用 TCP 的 500ms 定时器处理的
* 最大报文长度
   * MSS，在 SYN 报文中   
   * 路径上 MTU 发现机制
* TCP 的半关闭   
   * 被动关闭的一方在收到 FIN 之后还可以发送数据。
* TCP 的状态图
   * 主动关闭 VS. 被动关闭
   * TIME_WAIT 2MSL 等待
      * 2MSL 是而为了该连接上的报文都挂了（在网络上被丢弃）。
      * 当 TCP 执行一个主动关闭，并发回最后的 ACK，该链接必须在 TIME_WAIT 状态停留 2MSL，**这样可让 TCP 再次发送最后的 ACK 以防止这个 ACK 丢失（另一端超时并重发最后的 FIN）**。
      * 等待期间端口不可用。
   * 主动终止服务器进程：
      * 正常关闭，执行的是主动关闭。
      * ctrl-d，直接发送 RST
* 复位报文段
   * RST，ICMP/ARP      
* 同时打开、同时关闭
   * 同时打开，只建立一条连接。
* TCP 选项
   * 窗口扩大选项是在 SYN 报文中
* TCP 服务器设计
   * 呼入连接请求队列：正等待连接请求的一端有一个固定长度的链接队列，该队列中的连接已被 TCP 接受，但还没有被应用层所接受。
      * backlog，队列长度
      * 当队列已满时，TCP 将不理会传入的 SYN，也不返回 RST 作为应答，因为这是一个**软错误**。


### Chapter 19：TCP 的交互数据流
* 交互式输入
* 经受延时确认
   * 通常 TCP 在接收到数据时并不马上发送 ACK；相反，它推迟发送，以便将 ACK 与需要沿该方向发送的数据一起发送。
   * 也称为 数据捎带 ACK。
   * 绝大多数实现为 200 ms。
   * 这里存在一个定时器。
   * 可以想到 Kafka 中的 LongPolling
* Nagle 算法
   * TCP\_NO\_DELAY 选项可以禁用 Nagle 算法。
   * Netty 中处理粘包
      * LineBasedFrameDecoder （换行符）
      * DelimiterBasedFrameDecoder（特殊字符）
      * FixedLengthFrameDecoder   （定长的报文）
      * LengthFieldBasedFrameDecoder （自定义解码器）


### Chapter 20：TCP 的从成块数据流
* 发送方的拥塞窗口 + 接收方的滑动窗口
* 接收方滑动窗口
   * 窗口大小：2048 字节
   * 窗口右侧不能左移。
   * PUSH 标志：客户端告诉接收方尽快将数据给应用程序处理。
* 慢启动
   * 发送方增加的接口：拥塞窗口（congestion window， cwnd）
   * 拥塞窗口是发送发使用的流量控制，通告窗口是接收方使用的流量控制。
   * 拥塞窗口被初始化为 1 个报文段，每收到一个 ACK，拥塞窗口与就增加一个报文（cwnd 以字节为单位，但是慢启动以报文段大小为单位进行增加）。
   * 发送方去拥塞窗口与通告窗口中的最小值作为发送的上限。
* 成块数据的吞吐量
   * 带宽时延乘积
      * 通道的容量 Copaticy(bit) = bandwidth(b/s) * round-trip-time(s)
   * 拥塞：大管道向小管道发送的时候会有这个现象。 
* 紧急方式
   * TCP 首部的 UGR 比特
   * 使用在 Telnet、Rlogin 和 FTP    

### Chapter 21：TCP 的超时与重传
* 重传定时器
   * 指数避退（exponential backoff）
* 对于每个链接，TCP 管理 4 个不同的定时器
   * 1. 重传定时器
   * 2. 2MSL 定时器
   * 3. 坚持定时器
   * 4. keep-alive 定时器
* RTT 往返时间测量
   * 卡恩（Karn）算法
   * 当一个超时和重传发生时，在重传数据的确认最后到达时，不能更新 RTT 计时器。
   * 平滑 RTT
* 拥塞避免算法
   * 目的：处理丢失分组的方法。
      * 慢启动算法的目的是为了降低分组进入网络的传输速率。
   * 算法假设，由于分组受到损坏引起的丢失是非常少的（远小于 1%）。
   * 拥塞算法和慢启动算法需要退每个链接维持两个变量：一个拥塞窗口 cwnd 和一个慢启动门限 ssthresh。
   * 过程
      * 1. 对一个戈丁的链接，初始化 cwnd 为 1 个报文段，ssthresh 为 65536 个字节
      * 2. TCP 输出例程的输出不能超过 cwnd 和接收方通告窗口的额大小。拥塞避免是发送方使用的流量控制，而通告窗口是接收方进行的流量控制。前者是发送方感受到的网络拥塞的网络拥塞的估计，而后者则与接收方在该链接上的可用缓存大小有关。
      * 3. 当拥塞发生时（超时或者收到重复确认），sstresh 被设置为当前窗口大小的一般（cwnd 和接收方通告窗口大小的最小值，但最小为 2 个报文段）。此外，如果是超时引起的拥塞，则 cwnd 别设置为 1 个报文段（这就是慢启动）。
      * 4. 当新的数据被对方确认时，就增加 cwnd，但增加的方法依赖于我们是否在进行慢启动或者拥塞避免。如果 cwnd 小于或等于 ssthresh，则正在进行慢启动，否则正在进行拥塞避免。
   * 关于 cwnd 增长速率
      * 慢启动阶段，是按照指数式曾江。
      * 拥塞避免阶段，cwnd += 1/cwnd 这种加性增长。
* 快速重传与快速恢复算法
   * 快速重传算法： 当发送方连续接收到 3 个或 3 个以上的重复 ACK，就重传丢失的数据报文段，而无需等待超时定时器溢出。      
   * 快速恢复算法：快速重传算法之后，执行的是拥塞控制算法，而不是慢启动算法。
* 按每条路由进行度量
* ICPM 的差错
   * 源站抑制、主机不可达和网络不可达
* 重新分组
   * 超时重传时，不一定要重传同样的报文段。TCP 允许进行重新分组而发送一个较大的报文段，这样有助于提高性能。 

### Chapter 22： TCP 的坚持定时器
* 发送方使用一个坚持定时器（persist timer）来周期性得向接收方查询，以便发现窗口是否已经增大。
   * 发送的报文称为窗口探查（windwo probe）
   * TCP 从不放弃发送窗口探查。
   * 在链接的一方需要发送数据单对方已经通告窗口大小为 0 时，就需要设置 TCP 的坚持定时器。

### Chapter 23： TCP 的保活定时器
* 保活并不是 TCP 规范中的一部分。    

### Chapter 24：TCP 的未来和性能
* TCP 这个系统的外部环境在变化。计算机性能更好，网络更宽。
* 路径 MTU 发现
* 长肥管道
* 扩大窗口选项
* 时间戳选项
* PAWS：防止回绕的序号
* T/TCP：为事务用的 TCP 扩展

### Chapter 25 SNMP：简单网络网关协议
* SNMP 是一种简单的，SNMP 管理进程和 SNMP 代理进程之间的请求-应答协议。


### Chapter 26 Telnet 和 Rlogin：远程登录
* 提供从客户进程远程登录到服务器进程。
* Rlogin 假设双方都是 Unix 系统，所以只提供了一个选项，它是一个简单的协议。
* Telnet 用于在不同类型的主机间建立链接。
* 两者都是 TCP 链接。

### Chapter 27 FTP：文件传输协议
* 在客户进程和服务进程之间有两个 TCP 链接。


### Chapter 28 SMTP：简单邮件传输协议
* 电子邮件包括在两端（发送方和接收方）都有一个用户代理以及两个或多个保温传输代理。 
* 邮件报文分为三个部分：信封、首部、正文。

### Chapter 29：网络文件系统
* NFS 为用户提供了透明的网络访问。
* NFS 的基础是 Sun RPC。
   * NFS 早期使用的是 UDP
   * 后来由 LAN 转到 WAN，开始使用 TCP
   
### Chapter 30：其他的 TCP/IP 应用程序
* 获取用户信息
   * Finger
   * Whois
* Internet 资源发现服务
   * Archie
   * WAIS
   * Gopher
   * Veronica
   * WWW

   
### 配置选项
* IP
* ARP、ICPM
* TCP、UDP         
* 这个调优的工作，需要怎样的知识？ 
   
