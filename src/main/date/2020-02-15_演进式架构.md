# 演进式架构
演进式架构的核心是采取小步变更，然后通过反馈环让团队的每个成员不断地从系统的发展中学习。 

### Chapter 1：软件架构
* 架构的完整概念：包括需求以及“各种特征”
   * 《软件系统架构 - 使用视点和视角利益相关者合作》
      * 视点：场景、功能、数据、并发、开发、部署、运维
         * 也有 4+1 模型：逻辑、物理、进程、开发 + 场景
      * 视角：安全、国际化、可扩展性、性能 etc
* 演进式架构
   * 一切都在变化，如何才能长期规划
   * 完成架构构建后，如何防止它组件演化 --- 耗散结构
* 增量变更
   * 包含两个方面：如何增量地构建软件和如何部署软件
* 引导性变更
   * 适应度函数
* 多个架构维度（视角）
   * 架构的关注点
   * 可审计性、数据、安全性、性能、合法性和伸缩性          
* 康威定律
   * 在设计系统时，组织所交付的方案结构将不可避免地与其沟通结构一致。
   * 逆康威定律
* 为何演进
   * 演进式架构的两个关键特征：增量和引导      
   * 演进是架构主要有三方面组成：增量变化、适应度函数和适当的耦合

   
### Chapter 2：适应度函数
* 演进式架构师支持跨多个维度进行的引导性增量变更的架构。
* 架构的适应度函数为某些架构特征提供了客观的完成性评估。
* 全系统适应度函数：适应度函数的集合，其中每个适应度函数对应架构的一个或多个维度。

### Chapter 3：实施增量变更 
* 演进式架构支持跨维度进行引导式增量变更。
* 将适应度函数纳入构建流程之中。
* 驱动敏捷软件方法论的引擎是内置的反馈环，如测试、持续集成和迭代等。
* 驱动开发
   * 数据驱动开发
   * 假设驱动开发：演进式架构、现代 DevOPs、变更需求和同时运行多版本应用的能力。

### Chapter 4：架构耦合
* 模块化
   * 模块化：描述的是相关代码的逻辑分组
   * 组件：是模块的物理封装
      * 有库和服务两类。
* 架构的量子和粒度
   * 架构量子：具有高功能内聚并可以独立部署的组件，它包括了支持系统正常工作的所有结构性元素。
   * 小的架构量子意味着更快的变更速度，因为其影响范围更小。
* 不同架构的演进能力
   * 大泥团架构
   * 单体架构
      * 非结构化的单体架构
      * 分层架构
      * 模块化的单体架构
      * 微内核架构
   * 事件驱动架构（EDA）
      * 代理模式
      * 中介模式
   * 服务导向架构（SOA）
      * 企业服务总线驱动的 SOA
      * 微服务架构
         * **微服务设计的重点是基于业务领域，而不是基于技术架构。**
         * **微服务的目标是创建有用的界限上下文，而不是让开发人员构建更小的服务。**
         * 微服务架构个七个原则：围绕业务领域建模、隐藏实现袭击、自动化文化、高度去中心化、独立部署、隔离失败、高度可观察
      * 基于服务的架构
         * 更大的服务粒度
         * 数据库作用域
            * 事务完整性很强的系统不太适合微服务，因为在服务间进行事务行为协调的成本太高。
   * 无服务架构
      * BaaS：Backend as a Service
      * FaaS：Function as a Service
         * 调用方必须处理所有的事务行为和其他复杂的协调工作。
* 架构演进能力的三个方面
   * 1. 增量变更
   * 2. 通过适应度函数引导变更
   * 3. 适当的耦合            
            
### Chapter 5：演进式数据
* 扩展收缩模式       
* 微服务架构不适合事务性很强的系统，因为微服务的架构量子太小。基于服务的架构往往更适合，因为它对架构量子大小没有严格的要求。
* 微服务：对于每个服务而言，小并不是必须的，能捕获有用的界限上下文才是关键。

### Chapter 6: 构建可演进的架构
* 演进机制
   * 识别受演进影响的架构维度
      * 架构师必须确定在演进中他们想要保护的架构维度。 
   * 为每个维度定义适应度函数
   * 使用部署流水线自动化适应度函数
* 全新的项目
* 改良现有的架构
   * 赋予现有架构演进能力取决于三个因素：组件耦合度、工程实践成熟度，以及开发人员构建是一个适应度函数的难易程度。   
   * 适当的耦合和内聚
      * 选择架构前，需要理解面临的业务问题
   * 工程实践
   * 适应度函数
      * 重构：在不改变既有计算机代码外部行为的情况下，对其进行调整的过程。
      * 重建：架构一般是重建，换一种架构模式。
   * 关于商业成品软件
      * 增量变更
      * 适当的耦合
      * 适应度函数
      * * 我们应努力使集成点保持一定的成熟度。如果无法做到这一点，那么你需要意识到系统的某些部分将更易于演进。
* 架构迁移
   * 迁移工作中的困难，主要是由于现有的耦合所致。
   * 不要因为元工作又去而构建架构。
   * 1. 迁移步骤
      * 在重建架构时，需要考虑所有所影响的维度
      * 挑战：服务力度、事务边界、数据库问题已经如何处理共享组件。
      * 将架构划分为领域，加上更好的团队结构和运维的隔离，会使得增量变更更容易，这是演进是架构的关键组成之一。
      * 粒度过小的组件则会导致过多的服务编排和消息通信所带来的的开销以及服务间的相互依赖。
   * 2. 演进模块之间的交互
      * 复制共享的库以消除耦合点。
      * 计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，除非该问题是由间接层太多导致的。
      * 当从单体应用迁移时，首先构建少量大型服务。
* 演进式架构构建指南
   * 1. 去除不要的可变性：使可能性空间减小
      * 通过不可变的基锤设施取代雪花服务器。
   * 2. 让决策可逆
      * 尽可能多地是决策可逆（在不过度工程化的前提下）。
      * 功能开关、服务路由
   * 3. 演进优于预测
      * 未知的未知问题是软件系统的大敌。
      * 由于未知的未知问题，所有架构都将是迭代式的，敏捷实践只是较早地意识到了这一点。 
   * 4. 构建防腐层
      * 最后责任时刻（The Last Responseible Moment）：避免过早引入复杂度。 
      * 构建即时防腐层来隔离库的跟新。
      * 开发人员熟悉工具的好处，却忽视所要做出的平衡。 
      * 控制应用中的耦合点，特别是外部资源模式架构时的关键职责之一。
      * **作为架构时，需要记住依赖在提供好处的同时，还会施加约束。**
   * 5. 服务模板
      * 保证一致性的常见方案，其中包含一些列预配置的公共基础设施库：服务发现、监控、日志、度量、认证/授权 等。
      * 适当耦合。
      * 使用服务模板仅将核实的架构部分偶合在一起，例如基础设施组件，团队可以从耦合中获益。
   * 6. 构建可牺牲的架构
      * 定义：在概念验证成功之后即被抛弃的架构。
      * 在管理上，你不该询问是否该构建一个实验性的系统然后将其抛弃。因为你一定会那样做。因此，做好抛弃它的计划，因为你终将如此。
      * 为了证明时长的存在，很多企业构建可牺牲架构来实现最小可行性产品。 
      * 在开发人员重建架构时候，第一步应该清楚哪些以往的设计妥协，即技术债。
   * 7. 应对外部变化
      * 外部依赖是所有开发平台的一个共同特征。 
      * 软件开发处在高松的层层抽象之上，每一层都建立在下层抽象之上。
      * 传递依赖管理被视为是有害的。 
      * 以拉去的方式获取外部依赖是开启依赖管理的良好开端。 
   * 8. 更新库与更新框架
      * 积极地更新框架依赖，消极地更新库。
   * 9. 持续交付优于快照
      * 相比快照，我们倾向于通过持续交付来处理（外部） 依赖。 
   * 10. 服务内部版本化
      * 在版本化服务时，我们倾向于内部版本华，一次只支持两个版本，而不是用版本号。

      
### Chapter 7: 演进式架构的陷阱和反模式
* 项目过程中的两种错误工程实践：**陷阱**和**反模式**
   * 反模式：不好的模式。
   * 陷阱：表面上像是个好主意，但是很快便显露出缺点。
* 技术架构
   * 反模式：供应商为王
      * 对于工具的选择，架构师需要了解其中的好处和限制，可以战略性地采用这种方式。
      * 无论从技术还是从业务流程的角度来看，将外部工具或框架置于架构的核心会严重限制架构的演进能力。 
      * **不要讲你的架构耦合，使得供应商为王**   
      * 构建防腐层。
   * 陷阱：抽象泄露
      * 所有重大的抽象在某种程度上都会泄露。
      * 始保持对当前抽象层一下至少一个抽象层的完全理解。
      * 架构师将关键集成点上的不变量定义为适应度函数，并在部署流水线运行它们，确保抽象不会意外泄露。
      * **了解复杂技术栈的脆弱部分，并通过适应度函数自动保护它们**
   * 反模式：最后 10% 的陷阱
   * 反模式：代码复用和滥用
      * 复用软件更像是器官移植而不是拼装高乐高。
      * 代码复用性越高，其可用性越低。
      * 代码的易用性和复用性往往成反比。
      * 微服务避免代码复用，遵循重复优于耦合的理念。
         * 微服务的目标并不是追求重复，而是隔离领域内的实体。
   * 除非组件团队可以跟上动态平衡的创新步伐，否则技术架构组件的复用最终注定会沦为反模式。
      * 当耦合点妨碍了演进或其他重要的架构特征时，通过分叉或重复来打破耦合。
      * 架构师必须持续评估架构特征的适应度，保证它们仍在提供价值吗，避免沦为内反模式。     
   * 陷阱：建立驱动开发
      * 不要为了架构而构建架构，构建架构是为了解决问题。
* 增量变更
   * 反模式：管理不当
   * “金发姑娘“管理
      * 小型项目：对扩展性和性能没有严格要求的简单项目。
      * 中兴项目：
      * 大型项目
   * 陷阱：发布过慢
      * 交付周期：从一个想法开始到他在软件中实现所耗费的时间。 
      * 生产周期：即启动和完成单位工作所用的时间。 
      * 演进的速度和生产周期成正比，生产周期越短，演进越快。
* 业务问题
   * 陷阱：产品定制
      * 为每个客户定制、永久的功能开关、产品驱动定制化
   * 反模式：报表
   * 陷阱：规划视野
      * 沉没成本     

### Chapter 8: 构建演进式架构
* 组织因素
   * 在构建演进式架构时，围绕领域而不是技术能力组建团队具有许多优势和一些共同特征。 
   * 全功能团队：业务分析师、架构师、测试人员、运维人员、数据人员
   * 围绕业务能力组织团队
      * 按照业务能力而非智能来组织团队。 
   * 产品高于项目
   * 应对外部变化
   * 团队成员之间的连接数
      * 尽量减少开发团队之间的连接数
* 团队的耦合特征
   * 文化：特定人群和社会的想法、习俗及社会行为。
   * 了解团队文化，通过问题：
      * 是否团队所有人都知道什么是适应度函数，并考虑了新工具或产品选型对演进新适应度函数的影响？
      * 团队是否衡量了系统与所定义的适应度函数的匹配程度？ 
      * 工程师是否理解内聚和耦合？
      * 是否讨论了什么领域和技术概念该整合到一起？ 
      * 团队是基于变更能力还是基于他们想学习的技术来选择解决方案？
      * 团队对业务变更如何做出反应？ 他们是否难于完成小的变更，活在小的业务变更上花费了太多的时间？ 
      * **告诉我你的衡量标准，我就告诉你我会如何行动**
   * 实验文化
      * 衡量成功的真正标准是在 24 小时内完成的试验数量。
         * 从外部吸收想法
         * 鼓励明确的改进
         * 进行探针试验并稳定下俩
         * 创造创新实践
         * 采用基于集合的开发方式
         * 链接工程师和最终用户
* 首席财务官和预算
   * 架构量子和架构成本之间的关系

* 构建企业适应度函数
* 从何开始
   * 容易实现的目标
   * 最高价值优先
   * 测试
   * 基础设施
* 演进式架构的未来
   * 基于 AI 的适应度函数
   * 生成测试
* 为什么（不）呢
   * 公司为何决定构建演进式架构
      * 1. 可预测性和可演进性
      * 2. 规模
      * 3. 高级业务能力
      * 4. 以生产周期为业务指标
      * 5. 在量子级别隔离架构的特征
   * 企业为何不选择构建演进式架构
      * 1. 大泥团无法演进
      * 2. 其他架构特征占主导地位
         * LMAX 是领域专用架构的例子。
         * 大多数领域专用架构不关注演进性，因为其特定目的优先于其他问题。
      * 3. 牺牲架构
      * 4. 计划即将停止企业服务
   * 所附他人
   * 咨询柔道

* 商业案例
   * 未来已来，只是尚未流行。 
   * 没有后顾之忧地快速前行
   * 风险更低
   * 新能力
* 构建演进式架构            
